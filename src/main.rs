// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use serde_json;
use serde::{Deserialize, Serialize};
use std::env;


#[derive(Serialize, Deserialize, Debug)]
pub struct Output {
    pub initial_number: u32,
    pub next_number: u32,
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 5 {
        eprintln!("Usage: {} <method_id> <receipt_path> <initial_state> <final_state>", args[0]);
        std::process::exit(1);
    }
    
    // Parse the arguments
    let method_id = &args[1];
    let receipt_path = &args[2];
    let initial_state = &args[3];
    let final_state = &args[4];

    // Perform the verification
    let receipt_content = std::fs::read_to_string(receipt_path).unwrap();
    let receipt: risc0_zkvm::Receipt = serde_json::from_str(&receipt_content).unwrap();
    perform_verification(method_id, receipt, initial_state, final_state);
}

fn perform_verification(
    method_id: &String,
    receipt: risc0_zkvm::Receipt,
    initial_state: &String,
    final_state: &String,
) {
    let output: Output = receipt.journal.decode().unwrap();

    if output.initial_number
        != u32::from_str_radix(initial_state, 16).expect("Invalid initial state string")
    {
        panic!("Initial state mismatch");
    }

    if output.next_number
        != u32::from_str_radix(final_state, 16).expect("Invalid final state string")
    {
        panic!("Final state mismatch");
    }

    let mut decoded_method_id: [u32; 8] = [0; 8];
    for i in 0..8 {
        decoded_method_id[i] = u32::from_str_radix(
            &method_id
                .get(8 * i..8 * i + 8)
                .expect("Invalid method ID string"),
            16,
        )
        .expect("Invalid method ID string")
    }
    receipt
        .verify(decoded_method_id)
        .expect("Verification failed");

    println!("output: {} > {}", output.initial_number, output.next_number);
}